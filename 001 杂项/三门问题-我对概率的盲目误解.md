~~使用rust来模拟如下，请注意：主持人不是在选择了第一个choice后再放置物体的。主持人放置了物体，然后女士选择门。关键信息：**已知第一个choice是错的**。
穷举所有情景，我们处在其中的“第一个是错的”的分支中，剩下的~~
按照上面所描述的事件，剩下的两个门几率相同。不过，问题实际是如下的：
1. 主持人摆好三个门后的物体，一辆汽车，两只山羊
2. 女士选择一门，主持人打开剩余两门中的一个，是山羊
3. 女士应该改变选择吗？
这里很好理解，并且没有任何误会了。我才人们之所以疑惑，就是因为这样简单的问题在描述中使人头脑发昏，错成了我先前划掉的描述。
1. 假设主持人打开的门，是汽车...那就可惜了；是山羊的话，是哪种情况的山羊呢？汽车+山羊，还是山羊+山羊？这是一个2、3 的概率问题。
2. 这个概率有两层：女士选择了1/3的可能，然后分成了1 1 1/2三种情况呢。
```
use rand::Rng;

  

fn simulate_monty_hall(switch: bool, num_simulations: i32) -> f64 {

    let mut wins = 0;

    let mut rng = rand::thread_rng();

  

    for _ in 0..num_simulations {

        // Set up doors (0, 1, 2) and randomly place the car

        let car_door = rng.gen_range(0..3);

        // Player makes initial random choice

        let initial_choice = rng.gen_range(0..3);

        // Host opens a door that's neither the car nor the player's choice

        let host_door = (0..3)

            .find(|&d| d != car_door && d != initial_choice)

            .unwrap();

  

        // Final choice depends on whether player switches

        let final_choice = if switch {

            // If switching, choose the door that's neither initial choice nor host's opened door

            (0..3).find(|&d| d != initial_choice && d != host_door).unwrap()

        } else {

            // If not switching, stick with initial choice

            initial_choice

        };

  

        // Check if won

        if final_choice == car_door {

            wins += 1;

        }

    }

  

    wins as f64 / num_simulations as f64

}

  

fn main() {

    let num_simulations = 10000;

    let stay_win_rate = simulate_monty_hall(false, num_simulations);

    let switch_win_rate = simulate_monty_hall(true, num_simulations);

  

    println!("Results after {} simulations:", num_simulations);

    println!("Staying win rate: {:.1}%", stay_win_rate * 100.0);

    println!("Switching win rate: {:.1}%", switch_win_rate * 100.0);

}
```
